from flask import Flask, render_template, request, send_file
import datetime
import re
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
import asyncio
import aiohttp
import time
from fpdf import FPDF
from io import BytesIO
import os
import requests

# Flask app setup
app = Flask(__name__)

# WebDriver setup for Chrome with headless options
def setup_chrome_options():
    options = Options()
    options.add_argument("--headless")  # Run Chrome in headless mode
    options.add_argument("--disable-gpu")  # Disable GPU acceleration
    options.add_argument("--disable-extensions")  # Disable extensions
    options.add_argument("--blink-settings=imagesEnabled=false")  # Disable image loading
    options.add_argument("--disable-notifications")  # Disable notifications
    options.add_argument("--log-level=3")  # Set log level to only show critical errors
    options.add_experimental_option("excludeSwitches", ["enable-logging"])  # Exclude logging switches
    options.add_argument("--incognito")  # Run Chrome in incognito mode
    return options

# Initialize WebDriver with the specified options
driver = webdriver.Chrome(options=setup_chrome_options())

# Function to validate the format and year of a CVE ID
def validate_cve(cve_id):
    pattern = r"CVE-(\d{4})-(\d{4,})"  # Define regex pattern for CVE ID
    match = re.match(pattern, cve_id)
    if not match:
        return False, "Invalid format. Correct format is CVE-YYYY-XXXX."
    
    year = int(match.group(1))
    current_year = datetime.datetime.now().year
    if year < 1999 or year > current_year:
        return False, f"Year should be between 1999 and {current_year}."
    
    return True, None

# Function to check the status of a CVE ID (published, reserved, rejected)
def check_cve_status(cve_id):
    url = f"https://cveawg.mitre.org/api/cve-id/{cve_id}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return data.get('state')
    return None

# Function to asynchronously validate a list of links
async def validate_link(session, link):
    try:
        async with session.get(link, timeout=10) as response:
            return response.status == 200
    except Exception:
        return False

# Function to fetch and extract data from NIST website using Selenium
def fetch_nist_data(cve_id):
    url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
    
    driver.get(url)

    try:
        # Extract CVE ID, description, CVSS score, vector, and reference links
        cve_id_elem = driver.find_element(By.XPATH, '//*[@id="vulnDetailTableView"]/tbody/tr/td/h2/span').text
        description = driver.find_element(By.XPATH, '//*[@id="vulnDetailTableView"]/tbody/tr/td/div/div[1]/p').text
        
        try:
            base_score = driver.find_element(By.XPATH, '//*[@id="Cvss3NistCalculatorAnchor"]').text
            vector = driver.find_element(By.XPATH, '//*[@id="Vuln3CvssPanel"]/div/div[3]/span/span').text
        except:
            base_score = driver.find_element(By.XPATH, '//*[@id="Cvss2CalculatorAnchor"]').text
            vector = driver.find_element(By.XPATH, '//*[@id="Vuln2CvssPanel"]/div/div[3]/span/span').text

        ref_rows = driver.find_elements(By.XPATH, '//*[@id="vulnHyperlinksPanel"]/table/tbody/tr')
        links = [row.find_element(By.XPATH, 'td[1]/a').get_attribute("href") for row in ref_rows]
        
        # Validate reference links asynchronously
        async def fetch_valid_links():
            async with aiohttp.ClientSession() as session:
                tasks = [validate_link(session, link) for link in links]
                results = await asyncio.gather(*tasks)
                return [link for link, is_valid in zip(links, results) if is_valid]
        
        ref_links = asyncio.run(fetch_valid_links())
        
        # Return extracted NIST data
        nist_data = {
            "cve_id": cve_id_elem,
            "description": description,
            "base_score": base_score,
            "vector": vector,
            "references": ref_links
        }

    except Exception as e:
        driver.quit()
        return {"error": str(e)}
    
    return nist_data

# Asynchronous function to fetch data from MITRE's CVE API
async def fetch_mitre_data(cve_id):
    url = f"https://cveawg.mitre.org/api/cve/{cve_id}"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                try:
                    metadata = data['cveMetadata']
                    containers = data['containers']['cna']
                    affected = containers['affected'][0]
                    descriptions = containers['descriptions'][0]['value']
                    problem_type = containers['problemTypes'][0]['descriptions'][0]['description']
                    
                    references = [ref['url'] for ref in containers['references'] if 'url' in ref]
                    
                    # Validate references asynchronously
                    valid_references = await asyncio.gather(*(validate_link(session, ref) for ref in references))
                    references = [ref for ref, is_valid in zip(references, valid_references) if is_valid]
                    
                    mitre_data = {
                        "assigner_org": metadata.get('assignerShortName'),
                        "published": metadata.get('datePublished'),
                        "updated": metadata.get('dateUpdated'),
                        "vendor": affected.get('vendor'),
                        "product": affected.get('product'),
                        "versions": affected['versions'][0]['version'],
                        "description": descriptions,
                        "problem_type": problem_type,
                        "references": references,
                    }
                    return mitre_data
                except KeyError:
                    return {"error": "Unexpected data structure"}
            else:
                return {"error": f"Failed to fetch MITRE data: {response.status}"}

# Function to scrape exploit data from Exploit DB
def fetch_exploit_data(cve_id):
    url = f"https://www.exploit-db.com/search?cve={cve_id}&verified=true"
    driver.get(url)
    time.sleep(2)  # Wait for the page to load

    exploit_data_list = []
    
    try:
        while True:
            rows = driver.find_elements(By.XPATH, '//*[@id="exploits-table"]/tbody/tr')
            if not rows:
                break
            
            for row in rows:
                try:
                    title_link = row.find_element(By.XPATH, 'td[5]/a').get_attribute('href')
                    date = row.find_element(By.XPATH, 'td[1]').text
                    exploit_type = row.find_element(By.XPATH, 'td[6]').text
                    platform = row.find_element(By.XPATH, 'td[7]').text
                    author = row.find_element(By.XPATH, 'td[8]').text
                    download_link = row.find_element(By.XPATH, 'td[2]/a').get_attribute('href')

                    exploit_data = {
                        "title_link": title_link,
                        "date": date,
                        "type": exploit_type,
                        "platform": platform,
                        "author": author,
                        "download_link": download_link
                    }
                    exploit_data_list.append(exploit_data)
                except Exception:
                    continue  # Skip row if any element is not found

            # Check for a next page or end of results
            try:
                next_button = driver.find_element(By.XPATH, '//*[@id="pagination"]/li[@class="next"]/a')
                next_button.click()
                time.sleep(2)  # Wait for the next page to load
            except Exception:
                break  # No more pages or error clicking next button
    
    except Exception as e:
        return {"error": str(e)}
    
    return exploit_data_list

# Function to generate a PDF report from the fetched data
def generate_pdf(cve_id, nist_data, mitre_data, exploit_data):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Title
    pdf.set_font("Arial", 'B', size=16)
    pdf.set_text_color(0, 0, 0)  # Black color for title
    pdf.cell(200, 10, txt=f"CVE Report: {cve_id}", ln=True, align='C')
    pdf.ln(10)  # Add a line break

    # NIST Data
    pdf.set_font("Arial", 'B', size=14)
    pdf.set_text_color(0, 0, 128)  # Dark Blue color for section titles
    pdf.cell(200, 10, txt="NIST Data", ln=True, align='L')
    pdf.ln(5)
    pdf.set_font("Arial", size=12)
    pdf.set_text_color(0, 0, 0)  # Black color for text
    pdf.multi_cell(0, 10, txt=f"Description: {nist_data.get('description', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Base Score: {nist_data.get('base_score', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Vector: {nist_data.get('vector', 'N/A')}")
    pdf.ln(5)
    pdf.set_font("Arial", 'B', size=12)
    pdf.set_text_color(0, 0, 128)  # Dark Blue color for 'References' heading
    pdf.cell(200, 10, txt="References:", ln=True, align='L')
    pdf.set_font("Arial", size=12)
    pdf.set_text_color(0, 0, 255)  # Blue color for links
    for ref in nist_data.get('references', []):
        pdf.multi_cell(0, 10, txt=ref)
    pdf.ln(10)  # Add a line break

    # MITRE Data
    pdf.set_font("Arial", 'B', size=14)
    pdf.set_text_color(0, 0, 128)  # Dark Blue color for section titles
    pdf.cell(200, 10, txt="MITRE Data", ln=True, align='L')
    pdf.ln(5)
    pdf.set_font("Arial", size=12)
    pdf.set_text_color(0, 0, 0)  # Black color for text
    pdf.multi_cell(0, 10, txt=f"Assigner Org: {mitre_data.get('assigner_org', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Published: {mitre_data.get('published', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Updated: {mitre_data.get('updated', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Vendor: {mitre_data.get('vendor', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Product: {mitre_data.get('product', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Versions: {mitre_data.get('versions', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Description: {mitre_data.get('description', 'N/A')}")
    pdf.multi_cell(0, 10, txt=f"Problem Type: {mitre_data.get('problem_type', 'N/A')}")
    pdf.ln(5)
    pdf.set_font("Arial", 'B', size=12)
    pdf.set_text_color(0, 0, 128)  # Dark Blue color for 'References' heading
    pdf.cell(200, 10, txt="References:", ln=True, align='L')
    pdf.set_font("Arial", size=12)
    pdf.set_text_color(0, 0, 255)  # Blue color for links
    for ref in mitre_data.get('references', []):
        pdf.multi_cell(0, 10, txt=ref)
    pdf.ln(10)  # Add a line break

    # Exploit Data
    pdf.set_font("Arial", 'B', size=14)
    pdf.set_text_color(0, 0, 128)  # Dark Blue color for section titles
    pdf.cell(200, 10, txt="Exploit Data", ln=True, align='L')
    pdf.ln(5)
    pdf.set_font("Arial", size=12)
    pdf.set_text_color(0, 0, 0)  # Black color for text
    for exploit in exploit_data:
        pdf.set_font("Arial", 'B', size=12)
        pdf.cell(200, 10, txt=f"Title: {exploit.get('title_link', 'N/A')}", ln=True)
        pdf.set_font("Arial", size=12)
        pdf.set_text_color(0, 0, 0)  # Black color for details
        pdf.cell(200, 10, txt=f"Date: {exploit.get('date', 'N/A')}", ln=True)
        pdf.cell(200, 10, txt=f"Type: {exploit.get('type', 'N/A')}", ln=True)
        pdf.cell(200, 10, txt=f"Platform: {exploit.get('platform', 'N/A')}", ln=True)
        pdf.cell(200, 10, txt=f"Author: {exploit.get('author', 'N/A')}", ln=True)
        pdf.set_text_color(0, 0, 255)  # Blue color for download links
        pdf.cell(200, 10, txt=f"Download Link: {exploit.get('download_link', 'N/A')}", ln=True)
        pdf.set_text_color(0, 0, 0)  # Reset to black for the next item
        pdf.ln(5)  # Add a line break for separation

    # Save PDF to a file
    pdf_file_name = f"{cve_id}_report.pdf"
    pdf.output(pdf_file_name)
    return pdf_file_name

# Flask Routes

@app.route('/')
def index():
    # Render the main page with search form
    return render_template('index.html')

@app.route('/search', methods=['POST'])
def search_cve():
    cve_id = request.form['cve_id']
    
    # Validate CVE ID format and year
    is_valid, error_msg = validate_cve(cve_id)
    if not is_valid:
        return render_template('index.html', error=error_msg)

    # Check the status of the CVE ID
    status = check_cve_status(cve_id)
    if status in ["RESERVED", "REJECTED"]:
        error_msg = f"CVE ID {cve_id} is {status.lower()}."
        return render_template('index.html', error=error_msg)
    
    # Fetch data from NIST, MITRE, and Exploit DB
    nist_data = fetch_nist_data(cve_id)
    mitre_data = asyncio.run(fetch_mitre_data(cve_id))
    exploit_data = fetch_exploit_data(cve_id)
    
    # Render the result page with fetched data
    return render_template('result.html', cve_id=cve_id, nist_data=nist_data, mitre_data=mitre_data, exploit_data=exploit_data)

@app.route('/export_pdf/<cve_id>')
def export_pdf(cve_id):
    # Validate CVE ID format and year
    is_valid, error_msg = validate_cve(cve_id)
    if not is_valid:
        return render_template('index.html', error=error_msg)
    
    # Fetch data from NIST, MITRE, and Exploit DB
    nist_data = fetch_nist_data(cve_id)
    mitre_data = asyncio.run(fetch_mitre_data(cve_id))
    exploit_data = fetch_exploit_data(cve_id)

    # Generate PDF report from the fetched data
    pdf_file_name = generate_pdf(cve_id, nist_data, mitre_data, exploit_data)
    
    # Read and remove the temporary PDF file
    with open(pdf_file_name, 'rb') as pdf_file:
        pdf_content = pdf_file.read()
    
    os.remove(pdf_file_name)

    # Send the PDF file as a response to the client
    return send_file(
        BytesIO(pdf_content),
        as_attachment=True,
        download_name=f"{cve_id}.pdf",
        mimetype='application/pdf'
    )

# Run the Flask app
if __name__ == "__main__":
    app.run(debug=True)
